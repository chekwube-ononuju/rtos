# Recreate firmware scaffold and zip it for the user.
import os, zipfile, textwrap, pathlib

root = "/mnt/data/stm32_rtos_firmware"
for p in ["Core/Inc","Core/Src","Drivers"]:
    os.makedirs(os.path.join(root,p), exist_ok=True)

def write(rel, content):
    path = os.path.join(root, rel)
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w") as f:
        f.write(textwrap.dedent(content).strip()+"\n")
    return path

write("Core/Inc/rtos.h", r'''
    #pragma once
    #include <stdint.h>
    #include <stdbool.h>

    #ifdef __cplusplus
    extern "C" {
    #endif

    typedef void (*task_fn)(void *arg);

    typedef struct TCB {
      uint32_t *sp;
      struct TCB *next;
      uint8_t   prio;             // 0 = highest
      uint32_t  period;
      uint32_t  next_release;
      const char *name;
    } TCB;

    extern volatile uint32_t rtos_ticks;

    void     rtos_init(void);
    TCB*     rtos_add_task(task_fn fn, void *arg, uint8_t prio,
                           uint32_t period_ms, const char *name,
                           uint32_t *stack_mem, uint32_t stack_words);
    void     rtos_start(void);
    void     rtos_yield(void);
    void     rtos_delay(uint32_t ms);

    typedef struct { volatile int count; } sem_t;
    void     sem_init(sem_t *s, int initial);
    void     sem_give(sem_t *s);
    void     sem_take(sem_t *s);

    void     rtos_on_tick(void);
    uint32_t* rtos_select_next_sp(void);
    void     rtos_save_current_sp(uint32_t *sp);

    uint32_t* port_prepare_stack(task_fn entry, void *arg,
                                 uint32_t *stack_mem, uint32_t words);
    void     port_trigger_pendsv(void);

    #ifdef __cplusplus
    }
    #endif
''')

write("Core/Src/rtos.c", r'''
    #include "rtos.h"
    #include <string.h>

    #define MAX_PRIO  3

    static TCB *ready[MAX_PRIO+1];
    static TCB *wait_time = NULL;
    static TCB *current = NULL;

    volatile uint32_t rtos_ticks = 0;

    static void push(TCB **head, TCB *t){ t->next = *head; *head = t; }
    static TCB* pop(TCB **head){ TCB *t=*head; if(t) *head=t->next; return t; }

    TCB* rtos_add_task(task_fn fn, void *arg, uint8_t prio,
                       uint32_t period_ms, const char *name,
                       uint32_t *stack_mem, uint32_t stack_words) {
      static TCB pool[12]; static int used=0; if(used>=12) return 0;
      TCB *t = &pool[used++];
      t->sp = port_prepare_stack(fn, arg, stack_mem, stack_words);
      t->prio = (prio>MAX_PRIO)?MAX_PRIO:prio;
      t->period = period_ms;
      t->next_release = 0;
      t->name = name;
      push(&ready[t->prio], t);
      return t;
    }

    void rtos_init(void){
      memset(ready, 0, sizeof(ready));
      wait_time = NULL; current = NULL;
    }

    void rtos_on_tick(void){
      rtos_ticks++;
      TCB **pp = &wait_time;
      while(*pp){
        if((*pp)->next_release <= rtos_ticks){
          TCB *t=*pp; *pp=t->next; push(&ready[t->prio], t); continue;
        }
        pp=&(*pp)->next;
      }
    }

    uint32_t* rtos_select_next_sp(void){
      for(int p=0;p<=MAX_PRIO;p++){
        if(ready[p]){ current = pop(&ready[p]); return current->sp; }
      }
      return current ? current->sp : 0;
    }

    void rtos_save_current_sp(uint32_t *sp){
      if(current){ current->sp = sp; push(&ready[current->prio], current); }
    }

    void rtos_start(void){
      __asm volatile ( "mrs r0, control\n"
                       "orr r0, r0, #2\n"      // select PSP for thread mode
                       "msr control, r0\n"
                       "isb\n" ::: "r0");
      port_trigger_pendsv();
      while(1){}
    }

    void rtos_yield(void){ port_trigger_pendsv(); }

    void rtos_delay(uint32_t ms){
      if(!current) return;
      current->next_release = rtos_ticks + ms;
      current->next = wait_time; wait_time = current;
      port_trigger_pendsv();
    }

    void sem_init(sem_t *s, int initial){ s->count = initial; }
    void sem_give(sem_t *s){ __disable_irq(); s->count++; __enable_irq(); }
    void sem_take(sem_t *s){
      while(1){
        __disable_irq();
        if(s->count>0){ s->count--; __enable_irq(); break; }
        __enable_irq();
        rtos_yield();
      }
    }
''')

write("Core/Src/port_cm4.c", r'''
    #include "rtos.h"
    #include "stm32l4xx.h"
    #include "stm32l4xx_hal.h"

    void SysTick_Handler(void){
      HAL_IncTick();            // keep HAL tick working
      rtos_on_tick();
      SCB->ICSR = SCB_ICSR_PENDSVSET_Msk; // schedule switch
    }

    void port_trigger_pendsv(void){
      SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;
    }

    uint32_t* port_prepare_stack(task_fn entry, void *arg,
                                 uint32_t *stack_mem, uint32_t words){
      uint32_t *sp = stack_mem + words;
      sp = (uint32_t*)((uint32_t)sp & ~0x7UL); // align
      for(int i=0;i<8;i++){ *(--sp) = 0x00000000; } // R11..R4

      *(--sp) = 0x01000000;             // xPSR
      *(--sp) = (uint32_t)entry;        // PC
      *(--sp) = 0xFFFFFFFD;             // LR (EXC_RETURN to Thread/PSP)
      *(--sp) = 0x00000000;             // R12
      *(--sp) = 0x00000000;             // R3
      *(--sp) = 0x00000000;             // R2
      *(--sp) = 0x00000000;             // R1
      *(--sp) = (uint32_t)arg;          // R0
      return sp;
    }

    __attribute__((naked)) void PendSV_Handler(void){
      __asm volatile(
        "mrs   r0, psp                      \n"
        "isb                                \n"
        "cbz   r0, 1f                       \n"
        "stmdb r0!, {r4-r11}                \n"
        "bl    rtos_save_current_sp         \n"
        "1:                                  \n"
        "bl    rtos_select_next_sp          \n"
        "ldmia r0!, {r4-r11}                \n"
        "msr   psp, r0                      \n"
        "isb                                \n"
        "bx    lr                           \n"
      );
    }
''')

write("Core/Inc/drv_relay.h", r'''
    #pragma once
    #include "stm32l4xx_hal.h"
    void relay_init(GPIO_TypeDef* port, uint16_t pin, GPIO_PinState active_level);
    void relay_set(int on);
''')

write("Core/Src/drv_relay.c", r'''
    #include "drv_relay.h"
    static GPIO_TypeDef* s_port;
    static uint16_t s_pin;
    static GPIO_PinState s_active;

    void relay_init(GPIO_TypeDef* port, uint16_t pin, GPIO_PinState active_level){
      s_port = port; s_pin = pin; s_active = active_level;
      HAL_GPIO_WritePin(s_port, s_pin, (s_active==GPIO_PIN_SET)?GPIO_PIN_RESET:GPIO_PIN_SET);
    }
    void relay_set(int on){
      HAL_GPIO_WritePin(s_port, s_pin, on ? s_active : ((s_active==GPIO_PIN_SET)?GPIO_PIN_RESET:GPIO_PIN_SET));
    }
''')

write("Core/Inc/drv_ina219.h", r'''
    #pragma once
    #include "stm32l4xx_hal.h"
    #include <stdbool.h>

    typedef struct {
      I2C_HandleTypeDef *hi2c;
      uint8_t addr; // 7-bit
      float current_lsb; // A/bit
      float power_lsb;   // W/bit
    } ina219_t;

    bool ina219_begin(ina219_t *dev, I2C_HandleTypeDef *hi2c, uint8_t addr);
    bool ina219_read(ina219_t *dev, float *bus_v, float *current, float *power);
''')

write("Core/Src/drv_ina219.c", r'''
    #include "drv_ina219.h"

    #define REG_CONFIG      0x00
    #define REG_BUSV        0x02
    #define REG_POWER       0x03
    #define REG_CURRENT     0x04
    #define REG_CALIB       0x05

    static HAL_StatusTypeDef write16(I2C_HandleTypeDef *hi2c, uint8_t addr, uint8_t reg, uint16_t val){
      uint8_t b[2]={ (uint8_t)(val>>8), (uint8_t)(val&0xFF) };
      return HAL_I2C_Mem_Write(hi2c, addr<<1, reg, I2C_MEMADD_SIZE_8BIT, b, 2, 100);
    }
    static HAL_StatusTypeDef read16(I2C_HandleTypeDef *hi2c, uint8_t addr, uint8_t reg, uint16_t *val){
      uint8_t b[2];
      HAL_StatusTypeDef st = HAL_I2C_Mem_Read(hi2c, addr<<1, reg, I2C_MEMADD_SIZE_8BIT, b, 2, 100);
      *val = (b[0]<<8)|b[1];
      return st;
    }

    bool ina219_begin(ina219_t *dev, I2C_HandleTypeDef *hi2c, uint8_t addr){
      dev->hi2c = hi2c; dev->addr = addr;
      // 32V, 320mV shunt, 12-bit ADCs, continuous
      write16(hi2c, addr, REG_CONFIG, 0x399F);
      // Example calibration: ~100 uA/bit current LSB
      uint16_t calib = 4096;
      write16(hi2c, addr, REG_CALIB, calib);
      dev->current_lsb = 0.0001f;
      dev->power_lsb   = dev->current_lsb * 20.0f;
      return true;
    }

    bool ina219_read(ina219_t *dev, float *bus_v, float *current, float *power){
      uint16_t bus, cur, pow;
      if(read16(dev->hi2c, dev->addr, REG_BUSV, &bus)!=HAL_OK) return false;
      if(read16(dev->hi2c, dev->addr, REG_CURRENT, &cur)!=HAL_OK) return false;
      if(read16(dev->hi2c, dev->addr, REG_POWER, &pow)!=HAL_OK) return false;
      *bus_v = ((bus >> 3) * 0.004f);
      *current = ((int16_t)cur) * dev->current_lsb;
      *power = pow * dev->power_lsb;
      return true;
    }
''')

write("Core/Inc/esp8266.h", r'''
    #pragma once
    #include "stm32l4xx_hal.h"
    #include <stdbool.h>

    void esp8266_init(UART_HandleTypeDef *huart);
    bool esp8266_at(const char *cmd, const char *expect, uint32_t timeout_ms);
    bool esp8266_join_ap(const char *ssid, const char *pass, uint32_t timeout_ms);
    bool esp8266_post(const char *host_ip, int port, const char *path,
                      const char *json, uint32_t timeout_ms);
''')

write("Core/Src/esp8266.c", r'''
    #include "esp8266.h"
    #include <string.h>
    #include <stdio.h>

    static UART_HandleTypeDef *s_hu = NULL;

    void esp8266_init(UART_HandleTypeDef *huart){ s_hu = huart; }

    static HAL_StatusTypeDef uart_send(const char *s){
      return HAL_UART_Transmit(s_hu, (uint8_t*)s, strlen(s), 2000);
    }

    static int wait_for(const char *needle, uint32_t timeout_ms){
      uint32_t start = HAL_GetTick();
      static char buf[1024]; size_t n=0;
      memset(buf,0,sizeof(buf));
      while(HAL_GetTick() - start < timeout_ms && n < sizeof(buf)-1){
        uint8_t b;
        if(HAL_UART_Receive(s_hu, &b, 1, 10)==HAL_OK){
          buf[n++] = b; buf[n]=0;
          if(strstr(buf, needle)) return 1;
        }
      }
      return 0;
    }

    bool esp8266_at(const char *cmd, const char *expect, uint32_t timeout_ms){
      uart_send(cmd); uart_send("\r\n");
      return wait_for(expect, timeout_ms);
    }

    bool esp8266_join_ap(const char *ssid, const char *pass, uint32_t timeout_ms){
      esp8266_at("ATE0", "OK", 500);
      esp8266_at("AT+CWMODE=1", "OK", 1000);
      char line[160];
      snprintf(line, sizeof(line), "AT+CWJAP=\"%s\",\"%s\"", ssid, pass);
      uart_send(line); uart_send("\r\n");
      return wait_for("WIFI GOT IP", timeout_ms);
    }

    bool esp8266_post(const char *host_ip, int port, const char *path,
                      const char *json, uint32_t timeout_ms){
      char line[192];
      snprintf(line, sizeof(line), "AT+CIPSTART=\"TCP\",\"%s\",%d", host_ip, port);
      uart_send(line); uart_send("\r\n");
      if(!wait_for("OK", 5000) && !wait_for("ALREADY CONNECTED", 500)) return false;

      char req[512];
      int body_len = strlen(json);
      int n = snprintf(req, sizeof(req),
        "POST %s HTTP/1.1\r\n"
        "Host: %s\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %d\r\n"
        "Connection: close\r\n\r\n"
        "%s", path, host_ip, body_len, json);

      snprintf(line, sizeof(line), "AT+CIPSEND=%d", n);
      uart_send(line); uart_send("\r\n");
      if(!wait_for(">", 3000)) return false;
      HAL_UART_Transmit(s_hu, (uint8_t*)req, n, 5000);
      int ok = wait_for("SEND OK", timeout_ms) && wait_for("200", timeout_ms);
      esp8266_at("AT+CIPCLOSE", "OK", 2000);
      return ok;
    }
''')

write("Core/Inc/tasks.h", r'''
    #pragma once
    void tasks_init(void);
''')

write("Core/Src/tasks.c", r'''
    #include "rtos.h"
    #include "drv_ina219.h"
    #include "drv_relay.h"
    #include "esp8266.h"
    #include "stm32l4xx_hal.h"
    #include <stdio.h>

    extern I2C_HandleTypeDef hi2c1;
    extern UART_HandleTypeDef huart2;

    #define RELAY_PORT GPIOA
    #define RELAY_PIN  GPIO_PIN_8
    #define RELAY_ACTIVE GPIO_PIN_RESET   // active-LOW

    static const char* WIFI_SSID = "YourSSID";
    static const char* WIFI_PASS = "YourPassword";
    static const char* HOST_IP   = "192.168.1.50";
    static const int   HOST_PORT = 5050;

    volatile float g_v1,g_i1,g_p1,g_v2,g_i2,g_p2;
    static float threshold_w = 2.0f;

    static ina219_t s1, s2;

    static void task_sampler(void *arg){
      (void)arg;
      while(1){
        ina219_read(&s1, (float*)&g_v1, (float*)&g_i1, (float*)&g_p1);
        ina219_read(&s2, (float*)&g_v2, (float*)&g_i2, (float*)&g_p2);
        rtos_delay(1);
      }
    }

    static void task_comm(void *arg){
      (void)arg;
      esp8266_init(&huart2);
      esp8266_at("AT", "OK", 1000);
      esp8266_join_ap(WIFI_SSID, WIFI_PASS, 20000);

      char json[160];
      while(1){
        snprintf(json, sizeof(json),
          "{\"v1\":%.3f,\"i1\":%.3f,\"p1\":%.3f,\"v2\":%.3f,\"i2\":%.3f,\"p2\":%.3f}",
          g_v1,g_i1,g_p1,g_v2,g_i2,g_p2);
        esp8266_post(HOST_IP, HOST_PORT, "/ingest", json, 8000);
        rtos_delay(200);
      }
    }

    static void task_control(void *arg){
      (void)arg;
      relay_init(RELAY_PORT, RELAY_PIN, RELAY_ACTIVE);
      int over=0;
      while(1){
        if(g_p1 > threshold_w || g_p2 > threshold_w) over++; else over=0;
        relay_set(over>5);
        rtos_delay(10);
      }
    }

    void tasks_init(void){
      ina219_begin(&s1, &hi2c1, 0x40);
      ina219_begin(&s2, &hi2c1, 0x41);
      static uint32_t stk_sampler[512/4];
      static uint32_t stk_comm[1024/4];
      static uint32_t stk_control[512/4];
      rtos_add_task(task_sampler, NULL, 0, 1,   "sampler", stk_sampler, 512/4);
      rtos_add_task(task_comm,    NULL, 1, 200, "comms",   stk_comm,    1024/4);
      rtos_add_task(task_control, NULL, 2, 10,  "control", stk_control, 512/4);
    }
''')

write("Core/Src/main.c", r'''
    #include "main.h"
    #include "rtos.h"
    #include "tasks.h"

    extern void SystemClock_Config(void);
    extern void MX_GPIO_Init(void);
    extern void MX_I2C1_Init(void);
    extern void MX_USART2_UART_Init(void);

    int main(void){
      HAL_Init();
      SystemClock_Config();
      MX_GPIO_Init();
      MX_I2C1_Init();
      MX_USART2_UART_Init();

      HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);

      rtos_init();
      tasks_init();
      rtos_start();
      while (1) { }
    }
''')

write("README.txt", r'''
    # STM32 Minimal RTOS Firmware (NUCLEO-L476RG)

    Copy `Core/Inc/*.h` and `Core/Src/*.c` into your CubeIDE project (you may overwrite `main.c`).
    CubeMX pinout required:
      - I2C1 on PB8 (D15) SCL and PB9 (D14) SDA, 400 kHz
      - USART2 on PA2 (D1) TX and PA3 (D0) RX, 115200
      - GPIO Output on PA8 (D7) for RELAY_IN (initial HIGH if relay is active-LOW)

    Edit `Core/Src/tasks.c` to set your Wi-Fi SSID/PASS and the dashboard IP/port.
''')

zip_path = "/mnt/data/stm32_rtos_firmware.zip"
with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
    for dirpath, _, filenames in os.walk(root):
        for fn in filenames:
            full = os.path.join(dirpath, fn)
            z.write(full, os.path.relpath(full, root))

zip_path
